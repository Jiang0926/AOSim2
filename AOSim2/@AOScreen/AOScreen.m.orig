classdef AOScreen < AOGrid
	% AOScreen class.
	%
	% This is essentially a simplified AOPhaseScreen class, but dealing
	% only in wavefronts measured in meters.  There are methods to convert
	% the result to phase, but you have to define a reference lambda.
	%
	% Written by: Johanan L. Codona, Steward Observatory: CAAO
	% 20090417 JLCodona.  AOSim2.
	
	% Public properties
	properties(Access='public', SetAccess='public')
		altitude = 0.;	% Default is on the ground.
		lambdaRef = AOField.VBAND;
	
		mirror = false;  % This is like a height doubler.
		touched = true;
        radius = 1; % This is for Zernike reference.
	end
	
	% Private
	properties(SetAccess='private', GetAccess='public')
		thickness;
		r0 = 0.15;
		Cn2;
	end
	
	%% Methods
	methods
		% Constructors
		function PS = AOScreen(varargin)
			
			% (nxy,r0,lambda)
			PS = PS@AOGrid(varargin{1});

			if(length(varargin)>1)
				PS.r0 = varargin{2};
			end
			
			if(length(varargin)>2)
				PS.lambdaRef = varargin{3};
			end

			PS.thickness = 100;
			PS.Cn2 = PS.r0^(-5/3)/0.423/(2*pi/PS.lambdaRef)^2/PS.thickness;
			
			PS.nanmap = 1; % Make clear beyond the turbulence.
		end
		
		function PS = setCn2(PS,cn2,thick)
			if(nargin<3)
				thick = 1;
			end
			
			PS.thickness = thick;
			PS.Cn2 = cn2;
			PS.r0 = (0.423*(2*pi/PS.lambdaRef)^2*cn2*PS.thickness)^(-3/5); % see Roddier
			PS.touch;
		end
		
		function PS = setR0(PS,r0,thick)
			if(nargin<3)
				thick = 1;
			end
			
			PS.thickness = thick;
			PS.r0 = r0;
			PS.Cn2 = (r0^(-5/3))/0.423/(2*pi/PS.lambdaRef)^2/PS.thickness;
			PS.touch;
		end
		
		% Utilities
		
		function b = isPhase(G)
            b=true; % This is for confused programs that think this is an AOPhaseScreen.
		end
		
		function PSI = phasor(PS,lambda)
			tX(PS);
			
			if(nargin<2)
				lambda = PS.lambdaRef;
			end

			PSI = exp((2*pi*1i/lambda)*PS.grid);
		end
		
		function PHASE = phase(PS,lambda)
			tX(PS);
			
			if(nargin<2)
				lambda = PS.lambdaRef;
			end

			PHASE = (2*pi/lambda) * PS.grid;
		end
		
		function Rf = fresnel(a)
			Rf = sqrt(a.lambdaRef * a.altitude);
        end
		
        function S = touch(S)
            S.touch@AOGrid;
            S.touched = true;
        end
		
        function S = importAPP(S,FITSNAME,FRAME)
            % This is JLC specific.  Read in a PAC APP phase pattern.
            HEADER = fits_read_header(FITSNAME);
            START = double([1,1,FRAME]);
            STOP = double([HEADER.NAXIS1,HEADER.NAXIS2,FRAME]);
            APP = fits_read_image_subset(FITSNAME,START,STOP);
            S.grid_ = APP*(S.lambdaRef/2/pi);
            S.spacing(HEADER.XSPACING);
        end
        
        function S = addRipple(S,K,amp,phase)
            [X,Y] = S.COORDS();
            S + amp*cos(K(1)*X + K(2)*Y + phase);
            touch(S);
        end
        
        function S = addGaussian(S,CENTER,amp,width)
            [X,Y] = S.COORDS();
            S + amp*exp(-((X-CENTER(1)).^2 + (Y-CENTER(2)).^2)/width^2);
            touch(S);
        end

        function S = addGDelta(S,CENTER,amp,width,xy)
            [X,Y] = S.COORDS();
            if(nargin<5)
                error('need all args specified: addGDelta(S,CENTER,amp,width,xy)');
            end

            X = X - CENTER(1);
            Y = Y - CENTER(2);
            
            if(xy==1) % x is 1.  I know.  Confusing.
                S + amp*(X.*exp(-(X.^2 + Y.^2)/width^2));
            else
                S + amp*(Y.*exp(-(X.^2 + Y.^2)/width^2));
            end
            
            touch(S);
        end

        function S = addZernike(S,n,m,amp,D)
            if(nargin>4)
                S.radius = D/2;
            end
            
            [x,y] = S.COORDS(); % lowercase on purpose to match Zernike vars.
            x = x/S.radius;
            y = y/S.radius;
            zern = ZernikeStringR(n,m);
            S + amp*eval(zern);
            touch(S);
        end

		function S = addDiskHarmonic(S,n,m,amp,D)
            if(nargin<5)
                r = S.radius;
			else
				r = D/2;
			end
            
			if(nargin<4)
                amp = S.lambdaRef/2/pi;
			end
			
            [X,Y] = S.COORDS(); 
            X = X/r;
            Y = Y/r;
			R = sqrt(X.^2+Y.^2);
			TH = atan2(Y,X);
			
            DH = dh_dh(n,m,R,TH);
            S + amp*DH;
            touch(S);
        end
        
 	end % public methods.
end
